package pi179$Colecciones;

import java.util.HashSet;
import java.util.Set;

public class Pi182$Colecciones_CuentasUsuarios {

  public static void main(String[] args) {

    // Creando objetos de tipo Cliente3
    Cliente3 cl1 = new Cliente3("Antonio Banderas", "00001", 200000);
    Cliente3 cl2 = new Cliente3("Rafael Nadal", "00002", 250000);
    Cliente3 cl3 = new Cliente3("Penelope Cruz", "00003", 300000);
    Cliente3 cl4 = new Cliente3("Julio Iglesias", "00004", 300000);
    Cliente3 cl5 = new Cliente3("Antonio Banderas", "00001", 200000); // 'HashSet' no permite duplicados

    // Creando colecci�n de tipo 'Set' usando la clase 'HashSet' debido a que esta implementa la interfaz 'Set' // Interfaz Set // Colecci�n de tipo HashSet (Ventajas HashSet: No permite duplicados, Uso sencillo del m�todo add que ademas asegura no elementos duplicados || Inconvenientes: No tiene acceso aleatorio y poca eficiencia a la hora de ordenar elementos)
    Set <Cliente3> Cliente3sBanco = new HashSet <Cliente3>(); // 'Cliente3sBanco' ser� el nombre de la colecci�n // Set es una interfaz y como no se puede instanciar directamente una interfaz se ocupe intanciar la clase 'HashSet' que ya implementa esta interfaz

    // Agregando elementos a la colecci�n
    Cliente3sBanco.add(cl1); // El m�todo '.add' de la interfaz 'Set' permite agregar elementos del tipo genetico que se especific� antes
    Cliente3sBanco.add(cl2);
    Cliente3sBanco.add(cl3);
    Cliente3sBanco.add(cl4);
    Cliente3sBanco.add(cl5); // Realmente se imprime en consola lo del 'HashSet' porque apuntan a lugares de memoria completamente diferentes y los toma como si fueran diferentes objetos // Se usar�n los m�todos 'equals' y 'hashcode' de la clase Object para resolver esto // Ya resuelto sobreeescribiendo los m�todos este no aparece

    for (Cliente3 Cliente3 : Cliente3sBanco) { // bucle 'for each' para mostrar en consola los elementos de la colecci�n // Eclipse autogenerated 'for each' = fore -> SPACE -> ENTER
      System.out.println(Cliente3.getNombre() + " " + Cliente3.getnCuenta() + " " + Cliente3.getSaldo()); // Saldr�n ordenados alfabeticamente seg�n el nombre // La clase 'HashSet' no permite ordenar
    }

  }

}

class Cliente3 { // AutoGenerate 'getters' and 'setters' in Eclipse: Source -> Generate getters and setters... -> Select all

  public Cliente3(String nombre, String nCuenta, double saldo) { // Constructor // Cuando se instancie la clase Cliente3 habr� que especificar estos 3 datos
    this.nombre = nombre; // Almacenando los par�metros en los campos de clase
    this.nCuenta = nCuenta;
    this.saldo = saldo;
  }

  public String getNombre() {
    return nombre;
  }
  public void setNombre(String nombre) {
    this.nombre = nombre;
  }
  public String getnCuenta() {
    return nCuenta;
  }
  public void setnCuenta(String nCuenta) {
    this.nCuenta = nCuenta;
  }
  public double getSaldo() {
    return saldo;
  }
  public void setSaldo(double saldo) {
    this.saldo = saldo;
  }

  // Auto overriding some methods of the superClass Object: Source -> Generate hashCode() and equals() -> Check only nCuenta
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((nCuenta == null) ? 0 : nCuenta.hashCode());
    return result;
  }
  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    Cliente3 other = (Cliente3) obj;
    if (nCuenta == null) {
      if (other.nCuenta != null)
        return false;
    } else if (!nCuenta.equals(other.nCuenta))
      return false;
    return true;
  }

  private String nombre;
  private String nCuenta;
  private double saldo;

}
